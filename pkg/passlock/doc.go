/*
Package passlock provides functions for encrypting data using a key derived from a user-provided passphrase.
This uses AES-256 encryption to encrypt the provided data.

# Definition of terms:

  - plaintext: Data that has not been encrypted.
  - passphrase: A user-defined phrase used in place of an encryption key. Longer is better.
  - key: A key is a byte array of a size specific to the encryption algorithm used. An AES-128 key may not be used for AES-256 encryption operations.
  - salt: A salt is a generated byte array that is the same size as the key. This is generated using a secure random source, and is the entropy used for key generation and recovery.
  - key derivation: The process of securely creating a key from secure inputs. This process should be practically infeasible to reproduce without knowing the original inputs.
  - scrypt: A CPU and memory hard algorithm used for key derivation in this library. This was designed as an improvement to bcrypt to combat GPU brute force attacks.
  - AES: Stands for Advanced Encryption Standard. This is an encryption algorithm that - at the time of this writing - has not been shown to be directly broken in any way.
  - base key: The key used to encrypt/decrypt the payload in a MultiLocker.
  - surrogate key: A key used to encrypt the base key in a MultiLocker. This allows different passphrases to be used with the same encrypted payload.

# How it works:

A key and salt is generated from the given passphrase. The salt is appended to the encrypted payload so the same key can be derived later given the same passphrase.
Scrypt is memory and CPU hard, so it's impractical to brute force the salt to get the original passphrase, provided that sufficient tuning values are provided to the KeyGenerator.
A normal user is really only expected to define an iteration count for key generation.

The key, salt, and plaintext are passed to the Lock function to encrypt the payload and append the salt to it.
The key is recovered from the encrypted payload by passing the original passphrase and the payload to KeyGenerator.Derive.
The key and encrypted payload are passed to the Unlock function to decrypt the payload and return the original plain text.

The MultiLocker type extends the functionality above by providing the ability to use multiple surrogate keys to interact with the encrypted payload.
A MultiLocker is created using a KeyGenerator, and the encrypted payload is set by calling MultiLocker.Lock with the base passphrase and plaintext.
Once created, surrogate keys may be added to the MultiLocker that allow reading the encrypted payload.
A MultiLocker with surrogate keys and encrypted payload may be persisted to disk in binary form, and read back - including key generation settings.

A freshly read MultiLocker may not be changed in any way. Editing is enabled by calling EnableUpdate with the base passphrase.
After this call completes successfully, surrogate keys may be added or removed.
A new encrypted payload may only be set in a MultiLocker with the base passphrase.
A WriteMultiLocker allows surrogate passphrases to be used to lock a new payload, instead of just the base passphrase.

# General guidelines:
  - It's possible to customize the CPU cost, iteration count, and relative block size parameters directly for key generation. If you're not an expert, then don't use SetIterations, SetCPUCost, or SetRelativeBlockSize.
  - Both short and long delay iteration GeneratorOpt functions are provided, choose the correct iterations for your use-case using either SetLongDelayIterations or SetShortDelayIterations.
  - If encrypted data is intended to be stored indefinitely, choose the SetLongDelayIterations option for key generation.
  - This method of encryption (AES-GCM) supports encrypting and authenticating at most about 64GB at a time. You could get around this by splitting a very large file into multiple chunks that include some metadata to prevent reordering or truncating.
  - AES-256 is a good default for a lot of cases, with excellent security and good throughput speeds.
  - This library supports AES-256 since that is the best supported by the Go standard lib, but AES-128 may also be used for situations where more throughput is desired.
  - The main limit to operation speed comes from key generation (as intended), the AES key size makes a much smaller impact to performance unless a very large payload is encrypted.
  - When deriving the key from an encrypted payload, make sure that the same KeyGenerator settings are used. Not doing so will result in an incorrect key.
  - Technically, a surrogate key could be used to update a MultiLocker encrypted payload without invalidating other surrogate keys, since there are no cryptographic blockers to that. The base MultiLocker doesn't provide that function as a logical constraint only.
  - The MultiLocker base key may not be updated without invalidating all surrogate keys.
*/
package passlock
